<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<linkey rel="import" href="../polymer/polymer.html">

<script>
  window.Vaadin = window.Vaadin || {};

  /**
   * A mixin providing rovin tabindex
   */
  Vaadin.RovinTabindexMixin = superClass => class VaadinRovinTabindexMixin extends superClass {
    static get properties() {
      return {
        /**
         * The CSS selector used to get items
         */
        itemsSelector: {
          type: String,
          value: '*'
        },

        /**
         * The dom elements we can navigate and select
         */
        items: {
          type: Array,
          readOnly: true
        },

        /**
         * The index of the item selected in the items array
         */
        selected: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
          notify: true,
          observer: '_selectedChanged'
        }
      };
    }

    ready() {
      super.ready();
      this.addEventListener('selected', e => this._onSelected(e));
      this.addEventListener('close', e => this._onClose(e));
      this.addEventListener('keydown', e => this._onKeydown(e));

      Polymer.RenderStatus.afterNextRender(this, () => {
        this._setItems(Array.from(this.querySelectorAll(this.itemsSelector)));
        // `selected` property could be set before items are ready.
        this._selectedChanged(this.selected);
      });
    }

    get focused() {
      return this.items.reduce((prev, el) => prev || (el.focused ? el : null), null);
    }

    _onKeydown(e) {
      const key = e.which;
      // arrow left or right
      if (key == 37 || key == 39) {
        this._moveToNext(key == 39, false);
      }
      // TODO: handle other keys to focus items by the first letter.
    }

    // Move to the next/previous tab based on the ltr direction.
    // If doSelect is true, it selects the tab instead of moving the focus to it
    _moveToNext(ltr, doSelect) {
      const l = this.items.length;
      if (l) {
        const curIdx = doSelect ? this.selected : this.items.indexOf(this.focused);
        let newIdx = curIdx;
        do {
          newIdx += ltr ? 1 : -1;
          newIdx = newIdx < 0 ? l - 1 : newIdx == l ? 0 : newIdx;
        } while (this.items[newIdx].disabled && newIdx != curIdx);
        this.items[curIdx].tabIndex = -1;
        this.items[newIdx].tabIndex = 0;
        if (doSelect) {
          this.items[curIdx].selected = false;
          this.items[newIdx].selected = true;
        } else {
          this.items[newIdx].focus();
          this.items[curIdx].focused = false;
          this.items[newIdx].focused = true;
        }
        // TODO: move the current item to the scroller viewport
        // this.$.scroll.scrollLeft = this.items[newIdx].offsetLeft;
      }
    }

    _selectedChanged(idx) {
      const item = this.items && this.items[idx < 0 ? 0 : idx];
      if (item) {
        this.items.forEach(e => {
          e.selected = e == item ? true : false;
          e.tabIndex = e == item ? 0 : -1;
        });
      }
    }

    _onSelected(e) {
      if (!e.detail) {
        // Prevent the user to unselect the current item
        e.target.selected = true;
      } else {
        this.selected = this.items.indexOf(e.target);
      }
    }

    _onClose(e) {
      this.splice('items', this.items.indexOf(e.target), 1);
      this.removeChild(e.target);
    }
  };
</script>
